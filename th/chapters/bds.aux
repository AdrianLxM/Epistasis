\relax 
\@writefile{toc}{\contentsline {chapter}{\numberline {1}BigDataScript: A scripting language for data pipelines }{2}}
\newlabel{ch:bds}{{1}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {1.1}Preface}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {1.2}Introduction}{3}}
\@writefile{toc}{\contentsline {section}{\numberline {1.3}Methods}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3.1}Language overview}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3.2}Abstraction from resources}{9}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {1.1}\texttt  {pipeline.bds} program. A simple pipeline example featuring and a maximum of 6 h of execution time (Line 5)}{9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3.3}Robustness}{11}}
\@writefile{toc}{\contentsline {paragraph}{Lazy processing..}{11}}
\@writefile{toc}{\contentsline {paragraph}{Absolute serialization..}{12}}
\@writefile{toc}{\contentsline {paragraph}{Limitations..}{12}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3.4}Other features}{13}}
\@writefile{toc}{\contentsline {paragraph}{Automatic logging..}{13}}
\@writefile{lol}{\contentsline {lstlisting}{\numberline {1.2}\texttt  {pipeline\_2.bds} program. A two-step pipeline with task dependencies. The first step (line 9) requires to run \texttt  {myProcess} command on a hundred input files, which can be executed in parallel. The second step (line 19) processes the output of those hundred files and creates a single output file (using fictitious \texttt  {myProcessAll} command). It should be noted that we never explicitly state which hardware we are using: (i) if the pipeline is run on a dual-core computer, as each process requires 2 CPUs, one \texttt  {myProcess} instance will be executed at the time until the 100 tasks are completed; (ii) if it is run on a 64-core server, then 32 \texttt  {myProcess} instances will be executed in parallel; (iii) if it is run on a cluster, then 100 \texttt  {myProcess} instances will be scheduled and the cluster resource management system will decide how to execute them; and (iv) if it is run on a single-core computer, execution will fail owing to lack of resources. Thus, the pipeline runs independent of the underlying architecture. The task defined in line 18 depends on all the outputs from tasks in line 8 (\texttt  {mainOut <– outs}).}{13}}
\@writefile{toc}{\contentsline {paragraph}{Automatic command line parsing..}{15}}
\@writefile{toc}{\contentsline {paragraph}{Task re-execution..}{15}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3.5}BDS implementation}{16}}
\@writefile{toc}{\contentsline {paragraph}{Process identification.}{17}}
\@writefile{toc}{\contentsline {paragraph}{Timeout enforcement.}{17}}
\@writefile{toc}{\contentsline {paragraph}{Logging.}{17}}
\@writefile{lof}{\contentsline {figure}{\numberline {{1--1}}{\ignorespaces BDS report showing pipeline’s task execution timeline\relax }}{18}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{fig:bdsreport}{{{1--1}}{18}}
\@writefile{toc}{\contentsline {paragraph}{Exit status.}{19}}
\@writefile{toc}{\contentsline {paragraph}{Signal handling.}{19}}
\@writefile{toc}{\contentsline {section}{\numberline {1.4}Results}{19}}
\@writefile{lof}{\contentsline {figure}{\numberline {{1--2}}{\ignorespaces Execution example. (A) Script \texttt  {pipeline.bds}. (B) The script is executed from a terminal. The GO executable invokes main BDS, written in JAVA, performs lexing, parsing, compilation to AST and runs AST. (C) When the task statement is run, appropriate checks are performed. (D) A shell script \texttt  {task1.sh} is created, and a bds-exec process is fired. (E) bds-exec reports PID, executed the script \texttt  {task1.sh} while capturing stdout and stderr as well as monitoring timeouts and OS signals. When a process finishes execution, the exit status is logged\relax }}{20}}
\newlabel{fig:bdsexec}{{{1--2}}{20}}
\@writefile{lof}{\contentsline {figure}{\numberline {{1--3}}{\ignorespaces Whole-genome sequencing analysis pipeline’s flow chart, showing how computations are split across many nodes\relax }}{21}}
\newlabel{fig:bdsexec}{{{1--3}}{21}}
\@writefile{toc}{\contentsline {paragraph}{Architecture independence.}{21}}
\@writefile{toc}{\contentsline {paragraph}{Robustness..}{22}}
\@writefile{toc}{\contentsline {paragraph}{Scalability..}{22}}
\@writefile{lof}{\contentsline {figure}{\numberline {{1--4}}{\ignorespaces Architecture independence example. Notes: Running the same BDS-based pipeline, a sequence variant calling and analysis pipeline, on the same dataset (chr20) but different architectures, operating systems and cluster management systems.\relax }}{23}}
\newlabel{fig:bdsexec}{{{1--4}}{23}}
\@writefile{lof}{\contentsline {figure}{\numberline {{1--5}}{\ignorespaces Scaling dataset sized by a factor of \nobreakspace  {}1000. Notes: The same sample pipeline run on dataset of 2 GB (reads mapping to human chromosome 20) and 1.5 TB (whole-genome data set). Computational times vary according to system’s resources, utilization factor and induced hardware failures.\relax }}{23}}
\newlabel{fig:bdsexec}{{{1--5}}{23}}
\@writefile{toc}{\contentsline {section}{\numberline {1.5}Discussion}{23}}
\@setckpt{chapters/bds}{
\setcounter{page}{25}
\setcounter{equation}{0}
\setcounter{enumi}{0}
\setcounter{enumii}{0}
\setcounter{enumiii}{0}
\setcounter{enumiv}{0}
\setcounter{footnote}{0}
\setcounter{mpfootnote}{0}
\setcounter{QZ@ptcnt}{12}
\setcounter{part}{0}
\setcounter{chapter}{1}
\setcounter{section}{5}
\setcounter{subsection}{0}
\setcounter{subsubsection}{0}
\setcounter{paragraph}{0}
\setcounter{subparagraph}{0}
\setcounter{figure}{5}
\setcounter{table}{0}
\setcounter{QZ@TmpCnt}{1}
\setcounter{parentequation}{0}
\setcounter{lstnumber}{20}
\setcounter{ContinuedFloat}{0}
\setcounter{lemma}{0}
\setcounter{theorem}{0}
\setcounter{corollary}{0}
\setcounter{definition}{0}
\setcounter{propo}{0}
\setcounter{lstlisting}{2}
}
